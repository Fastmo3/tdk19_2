\chapter{Az alkalmazás implementációja}
\section{C\# implementáció}
% Meg kellene mutatni, hogy milyen API és újrahasznosítható elemek készültek el.
Az alkalmazás implementációja során fontos volt a C\# alapelveinek betartása (OOP elvek és nyelv specifikus elvek együttvéve). Szerencsére nem kellett újra feltalálni semmit, hisz a .NET rendelkezik Gráf rajzolóval, megjelenítővel, (hozzá különféle szolgáltatásokkal) és különféle standard formátumú fileokra készített feldolgozó modulokkal. Ebből adódóan a lényeges munka az átalakító modulok és az adatstruktúrák megírása volt. 
A step-by-step animáció úgy készül, hogy a megfelelő lépések legenerálódnak. A képek bekerülnek egy pipe-ba, ami a program beállításaiban megadott időzítő ütemére átadásra kerülnek megjelenítésre. 
A lépések addig számítódnak amíg a folyamat teljes egészében lefut, vagy egy olyan nodehoz nem ér ami felhasználói bevitelt vár. Ekkor a számítás szünetel és a UI megjelenítő előkészít egy input mezőt. Az input mező a felhasználói adatbevitel után (ha nem szükséges a következő lépéshez) eltűnik, az átláthatóság kedvéért. A mező tartalma átkerül feldolgozásra és általában token formájában kerül megjelenítésre. (Előfordulhat, hogy a program egy várakozási időt kér. Ez esetben is megjelenítődik token formájában, de a lényeg, a háló tranziciói csak egy bizonyos idő (feldolgozási-ciklusidő) függvényében tüzelnek. 

\section{Python implementáció}
A dolgozatban inkonzisztencia fedezhető fel programnyelvek terén. Ezt két okkal lehet alátámasztani. Az első, a dolgozat kezdeti szakaszán még csak a modellezésre gondoltunk, és ezért egy olyan nyelvet választottunk ami konverziós és automatizálási lehetőségekben gazdag, mindemellett hatékony és gyors is, valamint könnyebb vele a munka. Így esett a választás a C\# -ra. A dolgozat későbbi fejezetében tárgyaljuk az optimalizálást, azaz a validáció számítást. Ez később merült fel, és lett hozzáadva a dolgozathoz. Tervezett volt beépítése a  C\# -os anyaprogramba, de kisebb komplikáció adódott, ami a második indok; A C\# , lévén főleg nagyvállalati termelésre szánt programnyelv, azaz nem kutatási célokra készült. Ez a gyakorlatban azt jelenti, hogy bár LP feladatot lehet vele megoldani, nem rendelkezik megfelelő (ingyenes, vagy kényelmesen alkalmazható) LP feladatmegoldó könyvtárral. Ekkor került a fókusz a mára általánossá vált adatmodellezési, és kutatási nyelvre, a Pythonra. A Python PuLP csomagja egy LP feladat megoldó csomag, ami rendelkezik előregyártott parametrizálásra kész szubrutinokkal és struktúrákkal, amik megkönnyítik az LP megoldásokat. A megoldás egyenes úton előáll és nem kell extra műveletek sokaságát végezni. A nylev egyszerűsége miatt a Python nem szült különösebb problémákat. 

\section{Tesztelés, tapasztalatok}
% Itt kifejezetten az alkalmazás szemszögéből (nem pedig üzleti folyamatokra vonatkozóan) kellene bemutatni az alkalmazást.
A megjelenítéskor probléma lehet a gép számítási kapacitása, vagy annak kihasználhatatlansága. Tesztelés során nagy méretű hálók generálása során, a rajzfolyamat elhúzódhat, ez azt eredményezi, hogy a megjelenítéskor az animáció lassabb lesz, mert a megjelenítő szubrutin a képek elkészülésére vár. A lassulási probléma valamilyen szinten kiküszöbölhető a program aszinkron, több szálú futtatásával, de ekkor ügyelni kell arra, hogy az így generált képek megfelelő sorrendben legyenek pipeolva a megjelenítő számára. (Mivel a két tesztgépen nem volt értelme a többszálú futtatásnak, ezért kivételre került. Az első gépen a processzor egy magja csak több ezer node esetén kezdett lassabban dolgozni, a második gépen a 2 mag pedig nem hozott számottevő javulást.)
%a 2 programmmodul együtt mködése , resoning a 2 rész meglétére , miért alkalmaztuk illetve , miért optimális (futás stb)

