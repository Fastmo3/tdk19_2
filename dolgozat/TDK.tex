\documentclass[12pt,a4paper]{book}
\usepackage[utf8]{inputenc}
\usepackage[magyar]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{listings} %TODO configure for c#
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\date{\vspace{-5ex}}

%TODO a petri háló írása legyen konzisztens a C# ahol lehet zenei # el legyen hivatkozva az az "official"
%TODO a tranzició rövid vagy hosszú i?


\title{BPEL folyamatok Petri-háló alapú reprezentációja és szimulációja}

\begin{document}

\maketitle

\chapter{Bevezetés}

A dolgozat célja egy működő Petri háló  megjelenítő, szerkesztő %(és futtató?)
alkalmazás fejlesztése, és bemutatása. %TODO: (folyt)

\chapter{BPEL folyamatok}

A BPEL (Buisness Process Execution Language)üzleti folyamatok végrehajtó nyelve.
Az OASIS által kezelt XML alapú szabványt használ. 
A dokumentum felépítésében egy XML dokumentum, mely a WS-BPEL szabvány szerint validált. A BPEL programok szerkezetét célszerű egy mintával áttekinteni, a jobb megértéshez. %TODO link: http://docs.oasis-open.org/wsbpel/2.0/OS/wsbpel-v2.0-OS.html chapter 5 section 1
Vegyük a következő példát.  \textsl{Adott egy online rendelést felvevő cég. A cég egy automata segítségével generál számlákat A számla az ár kiszámítása, a futár kiválasztása, és a szükséges termelés ütemezése után kerül kiállításra.} A lépéseket az alábbi ábra mutatja be: %TODO insert fig1.png 
Az ábrán a téglalapok egy rész processzt jelentenek. Az egy blokkban különállóak pedig konkurens proceszeket. A szaggatott vonal szekvenciát jelöl, míg a teli/sima pedig vezérlő linkek, a konkurens processzek szinkronizációját, várakoztatását lehet velük megoldani. Az ábra nem képez átíratot, csak mint egy standard érthető vizualizáció segíti a megértést. 

A program következő része egy WSDL szabvány ami a portot adja meg a processz számára:
\newpage

\begin{verbatim}
<wsdl:definitions
   targetNamespace="http://manufacturing.org/wsdl/purchase"
   xmlns:sns="http://manufacturing.org/xsd/purchase"
   xmlns:pos="http://manufacturing.org/wsdl/purchase"
   xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
   xmlns:plnk="http://docs.oasis-open.org/wsbpel/2.0/plnktype"
   xmlns:xsd="http://www.w3.org/2001/XMLSchema">
   
   <wsdl:types>
      <xsd:schema>
         <xsd:import namespace="http://manufacturing.org/xsd/purchase"
          schemaLocation="http://manufacturing.org/xsd/purchase.xsd" />
      </xsd:schema>
   </wsdl:types> 

   <wsdl:message name="POMessage">
      <wsdl:part name="customerInfo" type="sns:customerInfoType" />
      <wsdl:part name="purchaseOrder" type="sns:purchaseOrderType" />
   </wsdl:message>

   <wsdl:message name="InvMessage">
      <wsdl:part name="IVC" type="sns:InvoiceType" />
   </wsdl:message>

   <wsdl:message name="orderFaultType">
     <wsdl:part name="problemInfo" element="sns:OrderFault"/>
   </wsdl:message>

   <wsdl:message name="shippingRequestMessage">
      <wsdl:part name="customerInfo" element="sns:customerInfo" />
   </wsdl:message>

   <wsdl:message name="shippingInfoMessage">
      <wsdl:part name="shippingInfo" element="sns:shippingInfo" />
   </wsdl:message>

   <wsdl:message name="scheduleMessage">
      <wsdl:part name="schedule" element="sns:scheduleInfo" />
   </wsdl:message> 

   <!-- portTypes supported by the purchase order process -->

   <wsdl:portType name="purchaseOrderPT">
      <wsdl:operation name="sendPurchaseOrder">
         <wsdl:input message="pos:POMessage" />
         <wsdl:output message="pos:InvMessage" />
         <wsdl:fault name="cannotCompleteOrder"
            message="pos:orderFaultType" />
      </wsdl:operation>
   </wsdl:portType>
   
   <wsdl:portType name="invoiceCallbackPT">
      <wsdl:operation name="sendInvoice">
         <wsdl:input message="pos:InvMessage" />
      </wsdl:operation>
   </wsdl:portType>

   <wsdl:portType name="shippingCallbackPT">
      <wsdl:operation name="sendSchedule">
         <wsdl:input message="pos:scheduleMessage" />
      </wsdl:operation>
   </wsdl:portType>

   <!-- portType supported by the invoice services -->

   <wsdl:portType name="computePricePT">
      <wsdl:operation name="initiatePriceCalculation">
         <wsdl:input message="pos:POMessage" />
      </wsdl:operation>      
      
      <wsdl:operation name="sendShippingPrice">
         <wsdl:input message="pos:shippingInfoMessage" />
      </wsdl:operation>
   </wsdl:portType>

   <!-- portType supported by the shipping service -->

   <wsdl:portType name="shippingPT">
      <wsdl:operation name="requestShipping">
         <wsdl:input message="pos:shippingRequestMessage" />
         <wsdl:output message="pos:shippingInfoMessage" />
         <wsdl:fault name="cannotCompleteOrder"
            message="pos:orderFaultType" />
      </wsdl:operation>
   </wsdl:portType>

   <!-- portType supported by the production scheduling process -->

   <wsdl:portType name="schedulingPT">
      <wsdl:operation name="requestProductionScheduling">
         <wsdl:input message="pos:POMessage" />
      </wsdl:operation>
      
      <wsdl:operation name="sendShippingSchedule">
         <wsdl:input message="pos:scheduleMessage" />
      </wsdl:operation>
   </wsdl:portType> 

   <plnk:partnerLinkType name="purchasingLT">
      <plnk:role name="purchaseService"
         portType="pos:purchaseOrderPT" />
   </plnk:partnerLinkType> 

   <plnk:partnerLinkType name="invoicingLT">
      <plnk:role name="invoiceService"
         portType="pos:computePricePT" />
      <plnk:role name="invoiceRequester"
         portType="pos:invoiceCallbackPT" />
   </plnk:partnerLinkType> 

   <plnk:partnerLinkType name="shippingLT">
      <plnk:role name="shippingService"
         portType="pos:shippingPT" />
      <plnk:role name="shippingRequester"
         portType="pos:shippingCallbackPT" />
   </plnk:partnerLinkType> 

   <plnk:partnerLinkType name="schedulingLT">
      <plnk:role name="schedulingService"
         portType="pos:schedulingPT" />
   </plnk:partnerLinkType>
</wsdl:definitions>
\end{verbatim}

A szükséges portok és linkek definiálása után most a rendelés processzét definiáljuk hasonlóképp. 
\begin{verbatim}
<process name="purchaseOrderProcess"
   targetNamespace="http://example.com/ws-bp/purchase"
   xmlns="http://docs.oasis-open.org/wsbpel/2.0/process/executable"
   xmlns:lns="http://manufacturing.org/wsdl/purchase"> 
   
   <documentation xml:lang="EN">
      A simple example of a WS-BPEL process for handling a purchase
      order.
   </documentation> 

   <partnerLinks>
      <partnerLink name="purchasing"
         partnerLinkType="lns:purchasingLT" myRole="purchaseService" />
      <partnerLink name="invoicing" partnerLinkType="lns:invoicingLT"
         myRole="invoiceRequester" partnerRole="invoiceService" />
      <partnerLink name="shipping" partnerLinkType="lns:shippingLT"
         myRole="shippingRequester" partnerRole="shippingService" />
      <partnerLink name="scheduling"
         partnerLinkType="lns:schedulingLT"
         partnerRole="schedulingService" />
   </partnerLinks> 

   <variables>
      <variable name="PO" messageType="lns:POMessage" />
      <variable name="Invoice" messageType="lns:InvMessage" />
      <variable name="shippingRequest"
         messageType="lns:shippingRequestMessage" />
      <variable name="shippingInfo"
         messageType="lns:shippingInfoMessage" />
      <variable name="shippingSchedule"
         messageType="lns:scheduleMessage" />
   </variables> 

   <faultHandlers>
      <catch faultName="lns:cannotCompleteOrder"
         faultVariable="POFault"
         faultMessageType="lns:orderFaultType">
         <reply partnerLink="purchasing"
            portType="lns:purchaseOrderPT"
            operation="sendPurchaseOrder" variable="POFault"
            faultName="cannotCompleteOrder" />
      </catch>
   </faultHandlers> 

   <sequence>
      <receive partnerLink="purchasing" portType="lns:purchaseOrderPT"
         operation="sendPurchaseOrder" variable="PO"
         createInstance="yes">
         <documentation>Receive Purchase Order</documentation>
      </receive>

      <flow>
         <documentation>
            A parallel flow to handle shipping, invoicing and
            scheduling
         </documentation>
         <links>
            <link name="ship-to-invoice" />
            <link name="ship-to-scheduling" />
         </links>
         <sequence>
            <assign>
               <copy>
                  <from>$PO.customerInfo</from>
                  <to>$shippingRequest.customerInfo</to>
               </copy>
            </assign>
            <invoke partnerLink="shipping" portType="lns:shippingPT"
               operation="requestShipping"
               inputVariable="shippingRequest"
               outputVariable="shippingInfo">
               <documentation>Decide On Shipper</documentation>
               <sources>
                  <source linkName="ship-to-invoice" />
               </sources>
            </invoke>
            <receive partnerLink="shipping"
               portType="lns:shippingCallbackPT"
               operation="sendSchedule" variable="shippingSchedule">
               <documentation>Arrange Logistics</documentation>
               <sources>
                  <source linkName="ship-to-scheduling" />
               </sources>
            </receive>
         </sequence>
         <sequence>
            <invoke partnerLink="invoicing"
               portType="lns:computePricePT"
               operation="initiatePriceCalculation"
               inputVariable="PO">
               <documentation>
                  Initial Price Calculation
               </documentation>
            </invoke>
            <invoke partnerLink="invoicing"
               portType="lns:computePricePT"
               operation="sendShippingPrice"
               inputVariable="shippingInfo">
               <documentation>
                  Complete Price Calculation
               </documentation>
               <targets>
                  <target linkName="ship-to-invoice" />
               </targets>
            </invoke>
            <receive partnerLink="invoicing"
               portType="lns:invoiceCallbackPT"
               operation="sendInvoice" variable="Invoice" />
         </sequence>
         <sequence>
            <invoke partnerLink="scheduling"
               portType="lns:schedulingPT"
               operation="requestProductionScheduling"
               inputVariable="PO">
               <documentation>
                  Initiate Production Scheduling
               </documentation>
            </invoke>
            <invoke partnerLink="scheduling"
               portType="lns:schedulingPT"
               operation="sendShippingSchedule"
               inputVariable="shippingSchedule">
               <documentation>
                  Complete Production Scheduling
               </documentation>
               <targets>
                  <target linkName="ship-to-scheduling" />
               </targets>
            </invoke>
         </sequence>
      </flow>
      
      <reply partnerLink="purchasing" portType="lns:purchaseOrderPT"
         operation="sendPurchaseOrder" variable="Invoice">
         <documentation>Invoice Processing</documentation>
      </reply>
   </sequence>
</process>
\end{verbatim}
 
 A kódban szereplő \texttt{<partnerLinks>} tartalmaz mindent (így közvetetten mindenkit) amik kapcsolatba kerül a processzel. Az elnevezés tükrözi a résztvevő partit, valamint a résztvevő feladatát, szándékát. A \texttt{<variables>} a változókat tartalmazza, míg a \texttt{<faultHandlers>} a hibakezelőket. A hibakezelés egy try-catch-finally "hibakezelőblokk" helyett az XML mentalitását tükröző módon kerül lekezelésre, a handlerek által. A kód többi része a processz standard definíciójához tartozik. A példák alapján elmondható, hogy a program a következő struktúra szerint épül fel.
\begin{itemize}
\item \textbf{Definíció: } a processz neve, névtere és különféle sémahívások, majd bővítmények, importok
\item \textbf{PartnerLinkek: } A megfelelő partnerek hozzáadása attribútumokkal. 
\item \textbf{Változók}
\item \textbf{Hibakezelők}
\item\textbf{Eseménykezelők}
\end{itemize}

\chapter{Petri-hálók és alkalmazásaik}

A Petri-háló egy matematikai leírómodell elosztott rendszerek bemutatására.
A modellt Carl Adam Petri készítette.
A modell nagyon hasonlít a programozók körében elterjedt folyamat ábrára.
A háló irányított élekből, helyekből és átmenetekből (\textsl{mint elemek}) áll.
Az élek csak két különböző típusú elem között állhatnak.
A helyeken pontok, ún. tokenek állhatnak.
A tokenek csak diszkrét számban fordulhatnak elő egy helyen, és a token átvitele atomi folyamat, azaz nem félbeszakítható.
A tokenek elláthatóak attribútummal is ilyen esetben a tokeneket "kiszínezzük" és színezett petri hálóról beszélünk. (ld. 2.2.) %TODO (LINK!)

Formálisan  a petri háló egy \((P, T, F)\) rendezett hármas, ahol 
\begin{itemize}
\item $P$ egy véges \textsl{hely} halmaz ,
\item $T$ egy véges átmenet halmaz,
\item $F\subseteq (P\times T\cup T\times P)$ pedig egy folyamat reláció
\end{itemize}

\section{Színezett Petri-hálók}

Konkurens folyamatok modellezése

\chapter{Az üzleti folyamatok elemeinek leképzése}

%TODO Ide kellene felsorolni, és részletesen leírni, hogy a BPEL egyes elemeinek milyen Petri-háló feleltethető meg.
A leképzéskor elsődlegesen az aktivitás elemei kerülnek a figyelem középpontjába, a séma és különböző definíciók csak másodlagos helyet kapnak. Ez azért lényeges, mert a séma nem egy dinamikus folyamatot ír le, hanem az adott folyamat és eleminek tulajdonságát. Mivel a Petri-háló egy folyamat személtetésére lett létrehozva ezért főleg az aktív elemek a szignifikánsak a konverzió során. Az alábbi elemeknek feleltetünk meg egy egy részhálót:
\begin{itemize}

\item \texttt{<receive>} A recieve egy megfelelő üzenet után engedi a folyamatot továbbhaladni, így várakoztatáshoz használható. A \texttt{<receive>} teljes terjedelmében:\\
\begin{verbatim}
<receive partnerLink="NCName"
   portType="QName"?
   operation="NCName"
   variable="BPELVariableName"?
   createInstance="yes|no"?
   messageExchange="NCName"?
   standard-attributes>
   standard-elements
   <correlations>?
      <correlation set="NCName" initiate="yes|join|no"? />+
   </correlations>
   <fromParts>?
      <fromPart part="NCName" toVariable="BPELVariableName" />+
   </fromParts>
</receive>
\end{verbatim}
A hálóban ezt egy tranzicióval könnyedén megoldhatjuk, hisz csak egy specifikus msg token kell a továbblépéshez, és a többit addig az előző helyen parkoltatja. 
\item \texttt{<reply>} A reply egy üzenetküldő elem, ami \texttt{<receive>; <onMessage>;<onEvent>} események után léphet akcióba. 
\begin{verbatim}
<reply partnerLink="NCName"
   portType="QName"?
   operation="NCName"
   variable="BPELVariableName"?
   faultName="QName"?
   messageExchange="NCName"?
   standard-attributes>
   standard-elements
   <correlations>?
      <correlation set="NCName" initiate="yes|join|no"? />+
   </correlations>
   <toParts>?
      <toPart part="NCName" fromVariable="BPELVariableName" />+
   </toParts>
</reply>
\end{verbatim}
A lekezelése az előző példával analóg módon, annyi különbséggel, hogy a tokenek nem parkolnak, hanem tovább mennek és a tranzíció csak akkor generál új tokent ha üzenetet kap egy ágról.

\item \texttt{<invoke>} Egy Bpel vagy épp egy webszolgáltatás meghívására szolgál és definiálja a szolgáltatás feladatát is. 
\begin{verbatim}
<invoke partnerLink="NCName"
   portType="QName"?
   operation="NCName"
   inputVariable="BPELVariableName"?
   outputVariable="BPELVariableName"?
   standard-attributes>
   standard-elements
   <correlations>?
      <correlation set="NCName" initiate="yes|join|no"?
         pattern="request|response|request-response"? />+
   </correlations>
   <catch faultName="QName"?
      faultVariable="BPELVariableName"?
      faultMessageType="QName"?
      faultElement="QName"?>*
      activity
   </catch>
   <catchAll>?
      activity
   </catchAll>
   <compensationHandler>?
      activity
   </compensationHandler>
   <toParts>?
      <toPart part="NCName" fromVariable="BPELVariableName" />+
   </toParts>
   <fromParts>?
      <fromPart part="NCName" toVariable="BPELVariableName" />+
   </fromParts>
</invoke>
\end{verbatim}
%TODO ebben nem vbagyok biztos hogy hogy lehet. Átad egy start tokent egy részhálónak??

\item \texttt{<assign>} Egy változó értékadására szolgáló esemény. Ellentétben egy imperatív értékadással egy assign blokkban bármennyi értékadás, másolás történhet, amíg azt a kliens kezelni tudja, így logikailag egy egységbe zárja a műveleteket.  
\begin{verbatim}
<assign validate="yes|no"? standard-attributes>
   standard-elements
   (
   <copy keepSrcElementName="yes|no"? ignoreMissingFromData="yes|no"?>
      from-spec
      to-spec
   </copy>
   |
   <extensionAssignOperation>
      assign-element-of-other-namespace
   </extensionAssignOperation>
   )+
</assign>
\end{verbatim}
Az assign nagyon egszerűen átírható egy tranzicióra ami a megfelelő tokenek színét módosítja. 
\item \texttt{<validate>} Egy sémára validálja az XML (BPEL) file-t. 
\begin{verbatim}
<validate variables="BPELVariableNames" standard-attributes>
   standard-elements
</validate>
\end{verbatim}
\item \texttt{<throw>}Egy rész processzen belül fault generálására szolgál. 
\begin{verbatim}
<throw faultName="QName"
   faultVariable="BPELVariableName"?
   standard-attributes>
   standard-elements
</throw>
\end{verbatim}
Nagyon egyszerűen egy fault tokent generáló tranzició komponens. Explicit hálórésze nincs, hanem a megfelelő inputtokenek megléte vagy hiánya generálja egy tranzició során. 

\item \texttt{<wait>} Időre vonatkoztatva várakoztat. Például 5000 tick vagy 14:00:23 (hh:mm:ss)
\begin{verbatim} 
<wait standard-attributes>
   standard-elements
   (
   <for expressionLanguage="anyURI"?>duration-expr</for>
   |
   <until expressionLanguage="anyURI"?>deadline-expr</until>
   )
</wait>
\end{verbatim}
Megadható egy részhálóval ami valójában egy oszcillátor és a megfelelő iteráció után folytat tokent küld. 
\item \texttt{<empty>} No-op (no operations) event szinkronizációra szolgál.
\begin{verbatim}
<empty standard-attributes>
   standard-elements
</empty>
\end{verbatim}
Beiktatható egy semleges tranzició és hely.
\item \texttt{<sequence>} Sorozatot ad meg.
\begin{verbatim}
<sequence standard-attributes>
   standard-elements
   activity+
</sequence>
\end{verbatim} Egyszerűen csak tranziciók és helyek összefűzése. 
\item \texttt{<if>} Standard kétirányú elágazás. Logikai XPATH kifejezést vár. 
\begin{verbatim}
<if standard-attributes>
   standard-elements
   <condition expressionLanguage="anyURI"?>bool-expr</condition>
   activity
   <elseif>*
      <condition expressionLanguage="anyURI"?>bool-expr</condition>
      activity
   </elseif>
   <else>?
      activity
   </else>
</if>
\end{verbatim}
Egy tranzició, mely tokenek függvényében más felé küldi tovább, vagy generál tokeneket. Analóg módon egy Swithc Case elágazás is definiálható vele.
\item \texttt{<while>} While loop. Végre hajt amíg az iterációs feltétel igaznak értékelődik ki. 
\begin{verbatim}
<while standard-attributes>
   standard-elements
   <condition expressionLanguage="anyURI"?>bool-expr</condition>
   activity
</while>
\end{verbatim}
Egy tranzició, mely token függvényében a folyamat egy korábbi pontjára csatol vissza, vagy ép egy későbbire, a feltétel hamis logikai állapota esetén. A feltétel persze egy színes token jelenléte, vagy tokenek száma is lehet. 
\item \texttt{<repeatUntil>} Egy do-while ciklusnak feleltethető annyi kivétellel, hogy akkor enged tovább, ha a feltétel igaz. 
\begin{verbatim}
<repeatUntil standard-attributes>
   standard-elements
   activity
   <condition expressionLanguage="anyURI"?>bool-expr</condition>
</repeatUntil>
\end{verbatim}
Az előzővel analóg módon megadható
\item \texttt{<forEach>} A kezdeti változó és a végváltozó különbsége +1 szer iteráltatja a gyerek elemet. Megadható párhuzamos feldolgozás is. Egy Complete condition segítségével megadható egy break utasítás ami kilép a forEachből. 
\begin{verbatim}
<forEach counterName="BPELVariableName" parallel="yes|no"
   standard-attributes>
   standard-elements
   <startCounterValue expressionLanguage="anyURI"?>
      unsigned-integer-expression
   </startCounterValue>
   <finalCounterValue expressionLanguage="anyURI"?>
      unsigned-integer-expression
   </finalCounterValue>
   <completionCondition>?
      <branches expressionLanguage="anyURI"?
         successfulBranchesOnly="yes|no"?>?
         unsigned-integer-expression
      </branches>
   </completionCondition>
   <scope ...>...</scope>
</forEach>
\end{verbatim} Egyszerű loop utasítás, azonban párhuzamosítás esetén a részhálóból megfelelő példányszámot generáltatunk. 
\item \texttt{<pick>}Üzenetek várására vagy timeout eseményre figyel. Ezek bármelyike a szubprocessz végrehajtásához vezet. 
\begin{verbatim}
<pick createInstance="yes|no"? standard-attributes>
   standard-elements
   <onMessage partnerLink="NCName"
      portType="QName"?
      operation="NCName"
      variable="BPELVariableName"?
      messageExchange="NCName"?>+
      <correlations>?
         <correlation set="NCName" initiate="yes|join|no"? />+
      </correlations>
      <fromParts>?
         <fromPart part="NCName" toVariable="BPELVariableName" />+
      </fromParts>
      activity
   </onMessage>
   <onAlarm>*
      (
      <for expressionLanguage="anyURI"?>duration-expr</for>
      |
      <until expressionLanguage="anyURI"?>deadline-expr</until>
      )
      activity
   </onAlarm>
</pick>
\end{verbatim}
\item \texttt{<flow>} konkurens elemek deklarálására szolgál. Linkek segítségével megadható függőségi viszony a gyerekek között. 
\begin{verbatim}
<flow standard-attributes>
   standard-elements
   <links>?
      <link name="NCName" />+
   </links>
   activity+
</flow>
\end{verbatim} A gyerek elemek scope-ját lehet vele szabályozni.
\item \texttt{<scope>}
\begin{verbatim}
<scope isolated="yes|no"? exitOnStandardFault="yes|no"?
   standard-attributes>
   standard-elements
   <partnerLinks>?
      ... see above under <process> for syntax ...
   </partnerLinks>
   <messageExchanges>?
      ... see above under <process> for syntax ...
   </messageExchanges>
   <variables>?
      ... see above under <process> for syntax ...
   </variables>
   <correlationSets>?
      ... see above under <process> for syntax ...
   </correlationSets>
   <faultHandlers>?
      ... see above under <process> for syntax ...
   </faultHandlers>
   <compensationHandler>?
      ...
   </compensationHandler>
   <terminationHandler>?
      ...
   </terminationHandler>
   <eventHandlers>?
      ... see above under <process> for syntax ...
   </eventHandlers>
   activity
</scope>
\end{verbatim}
Nem generál új elemet, csak a láthatósági, azaz visszacsatolási elemeket adja meg. 
\item \texttt{<compensateScope>}
\begin{verbatim}
<compensateScope target="NCName" standard-attributes>
   standard-elements
</compensateScope>
\end{verbatim}
\item \texttt{<compensate>}
\begin{verbatim}
<compensate standard-attributes>
   standard-elements
</compensate>
\end{verbatim}
\item \texttt{<rethrow>}
\begin{verbatim}
<rethrow standard-attributes>
   standard-elements
</rethrow>
\end{verbatim}
\item \texttt{<extensionActivity>}
\begin{verbatim}
<extensionActivity>
   <anyElementQName standard-attributes>
      standard-elements
   </anyElementQName>
</extensionActivity>
\end{verbatim}
\end{itemize}

\chapter{Szimulációs keretrendszer}

%TODO Be kell mutatni a C# nyelvű alkalmazást.

\section{Elvárások az alkalmazással szemben}

%TODO Itt kellene röviden áttekinteni az alkalmazással szemben támasztott követelményeket.

\section{Az alkalmazás felépítése}

%TODO Osztály és blokkdiagramok formájában be kellene mutatni, hogy milyen fő elemekből épül fel az alkalmazás.

\section{C\# implementáció}

%TODO Meg kellene mutatni, hogy milyen API és újrahasznosítható elemek készültek el.

\section{Tesztelés, tapasztalatok}

%TODO Itt kifejezetten az alkalmazás szemszögéből (nem pedig üzleti folyamatokra vonatkozóan) kellene bemutatni az alkalmazást.

\chapter{Komplex folyamatok vizsgálata}

\section{Első példa üzleti folyamat}

%TODO A címet majd nyilván át kell írni. Itt szerepelne egy bonyolultabb üzleti folyamat, és a konverzió eredménye.

\section{Második példa üzleti folyamat}

%TODO Hasonló az előző szakaszhoz, csak másik példával.


\chapter{Összegzés}

%TODO Leírni a dolgozatban elért eredményeket, és a további terveket!

\chapter{Hivatkozások}

%TODO A felhasznált hivatkozásokat már az elején célszerű összegyűjteni!

\end{document}
